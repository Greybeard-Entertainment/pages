#+AUTHOR: Aleksandr Petrosyan
#+TITLE: Rust is an OOP langauge

And a terrible functional one.  As in yes, there are anonymous functions (Java has those too), there are typeclasses, (if you squint hard enough, it's just like interfaces in Java), and in fact, pattern matching with tagged unions as a first class citizen can be the only thing that can even with some gusto be argued to be a functional feature.

But I'm not here to pounce on Rust's uselessness in teaching functional programming, that is a topic for another article.  I don't hate Rust and I don't want to fling more negativity its way than I have to.

But I will argue that Rust is truer to the original vision of OOP than the half-hearted attempts in Python, and the principled, though baroque approach adopted in Java.  It is not quiet on the same level as SmallTalk, JavaScript or Objective C, but those languages are largely misunderstood.
* Think objects

Many are under the impression that just because there isn't a word =class= native to Rust that this means that Rust doesn't have either classes or objects.  That is far from the truth.  In fact, I would argue that it forces you to think of objects more object like than either C++ or Java do.

Think about it.  Even something as "benign" as a string is a thing that has a beginning and an end.  It has a lifetime.  Within that lifetime, the object can be signalled.  Outside of that lifetime, signalling that object is forbidden, at least within the safe subset of the language.   There is a specific way of referencing an object in that context.  Unlike what the C++ (and C-like) syntax would suggest, there are no references in Rust.  There are borrows that for historical reasons (failure to plan ahead) are called mutable and immutable.  The reason there is a distinction is because of a rule that is being enforced by any Rust compiler, there can either be one reference through which a larger subset of operations is permitted (called a =mutable= reference, but this is a misnomer[fn:1]), or any number of more strict references that incidentally are only valid for the duration of the object's lifetime.

So how is this *not* OOP?

* Think classes and interfaces

If one has read my personal blog (this will be published here as well, at some point) you will know that things like inheritance are not intrinsic to OOP, but in fact solve a problem that is imposed by the paradigm.

To put it simply, instead of having direct access to most objects, one has to go through the pain of using signals and in the vast majority of cases, a function is not a good representation of what a signal is supposed to mean.  The corollary is that to map signal processing to methods to functions one basically needs to invent a way of generating a lot of boilerplate for trivial cases.

Let's illustrate on an example, perhaps a bit more contrived.  In an OOP world, there is no state, there are only signals.  The only way to communicate with an object to query its state is via signals.  But most signals are trivial.   A programming language like SmallTalk solved this problem easily, and the modern day problems related to it have more to do with the refusal to let go of the procedural aspects of programming than with the ineptitude(s) of the OOP paradigm.  Case in point, if one wanted to model the animal kingdom[fn:4], there are various signals one can process, like =eat=, =drink=, =reproduce= which are not simple queries of one's state[fn:3].  Yet, they are all trivial.  In the domain of the problem, most diets fall into categories of carnivore and herbivore, reproduction is similarly categorised very simply, with some notable outliers.  *Most of the signals for most of the objects are going to be identical.*

Now here I will make a distinction in how OOP languages traditionally solved the problem of repeated code, and why the solution in Rust is better, though not fundamentally different.

The first key assumption is that there is a clear hierarchy.  Within the C world, one would make a table for all unique functions and then point each individual entity's behaviour function pointer to that function.  So adding each new species entity isn't a hard task.  But the amount of work is certainly sub-optimal.  So one needs to spend a bit more time and see that there are categories of herbivore and Carnivore, vertebrate vs invertebrate, and to come up with a tree of inheritance that tends to categorise animals by which behaviour they engage in.  Sometimes, if the behaviour follows from another behaviour, and as a crucial difference from the function pointer approach, one can make a shortcut.  Java, Rust, Haskell, and C++ all do it that way.   But the devil is in the details.

With Java and C++, the assumption is that the participation in a particular way is tied to the object's self.  A cat, isn't just something that implements =Carnivore= but rather being a =Cat= is inextricable from being a =Carnivore=.  While it does make sense for a cat, consider what the inheritance hierarchy for a Platypus would look like.  Or any of a number of species that have convergent-evolved into a Crab.

With Haskell and Rust, one is given a way to make use of the categorical shortcuts, without making it too much a part of the type.  So a =Cat= happens to be =Carnivore=, being a =Carnivore= implies you have a mouth, so the ability to =drink= becomes obvious.  But at the same time, something like a =Platypus= isn't necessarily any of those things.  It can fall outside the regular categories and implement the basic low-level interfaces.

Now it might seem that because the technical difference is subtle, that the resulting code is also different only subtly.  But that is far from the case.  In Fallout New Vegas, the vehicles are hats attached to an entity.  This is not what a non-technical person would assume does the walking, but the way the code is organised makes it harder to do anything else.  With Haskell and Rust, the act of moving is less tightly coupled, and that gives one more room to manoeuvre with semantics.  This approach is more granular, and discourages trying to model every aspect of the domain taxonomic-ally.  You're writing procedural code where it's more convenient, but if you need to impose a hierarchy of interfaces, they are there and very minimal.

Incidentally, it's worth discussing the prototype-based inheritance model.  Philosophically speaking this is what we think there to be happening in the real world, =Mammal= and =Carnivore= are human categories that might not apply long term.  As such, the inheritance of signal processing methods is not something inherent to types, it's just something that tends to happen at construction.  Your being =Human= and your =entity.name == "Larry"= are on equal footing of being accidentally true, but not necessarily as meaningless as in C.

So with Rust, you are actually imposing a hierarchical structure, you're just not being overly sentimental about it, and you apply taxonomy based on practical considerations inherent in category theory, and not replicating and badly designing an object model /ad hoc/.

* Encapsulation

One of the most important aspects of OOP is the establishment of boundaries.  Alan Kay's original vision is that state is only meaningful from the perspective of the inherent methods.  Naturally this leads to even more code being required to query the state outside the object, more work and more thinking.  So programming languages like Java allowed some state to be public, similarly to C, but unlike C, any attempt to access the inaccessible state is a compilation error[fn:5].

So where does that leave us?

Well, in Rust pretty much all the same is present.  You can choose the visibility of an object's properties almost universally and granular.  This is as good as Java, because I can control the access to any field, without having to change its place.  Moreover, unlike having to remember which vague statement corresponds to which scope, I have a simple =crate= meaning "translation unit", =super= meaning "also in the enclosing module", and plain, meaning "in general".  This makes it more likely that I won't frivolously add a "getter" and a "setter" which essentially do the exact same as public access would.

More importantly, we have a natural way of deciding on two kinds of public access with respect to mutation.  The mutable borrow allows more interactions with an object, and thus even for things that are technically public, there is some granularity.  The main application of this is to ensure that the proper synchronisation steps have been taken to ensure a consistent view from all possible access points.  In other words, this is used to make sure that if someone reads the state of the object, it cannot be invalid.

Can the same not be done in Java? Of course it can.  The trouble is that the type system isn't going to warn you (or assuage your concerns) if you have used the wrong kind of access in a particular case.  But there is nothing revolutionary about Rust's use of obfuscation to prevent race conditions.

Nobody would ever think to articulate the borrow checking as a good old fashioned encapsulation mechanism.  Interior mutability is just a way to allow unprivileged mutation.  That's really it.

* Methods inherent to types

Rust has inherent =impl= s, do I need to say more than that?

To most, the ability to attach methods to objects is what OOP is all about, and I'm all for it.  Postfix notation has its benefits.  Is it easier to read something like
#+BEGIN_SRC haskell
mapErr (read thing) (toLower)
#+END_SRC

or like this? 
#+BEGIN_SRC rust
thing.read().map_err(String::to_lower)?
#+END_SRC

I'll admit that personally I think that the prefix is just as readable, but the pipeline approach with a very simple semantic, and the ability to do auto-completion after the full stop is entered is enticing.  While the mechanisms are exactly identical, the readability of the more verbose Rust is actually helped by the ability to use =.method()= calling conventions.

* Dynamic dispatch

This is somewhat controversial.  Rust is very opinionated about dynamic dispatch.  And it allows it, though it doesn't clearly communicate that sometimes (very often in fact) it is the right tool for the job.

There are reasons why people prefer explicit generics in Rust, but all of those come down to distrust of the LLVM devirtualiser.  A lot of the time, the compiler is smart enough to figure out what to do in your stead.  Trust it, a lot of the time that =Vec<Box<dyn TradeTraitPlzBeFast>>= is not actually using late binding; you don't need a "God" =enum=, all you need to know is if =dyn Trait= objects were useless, the Rust team would probably have gotten rid of it.  More so because trait objects don't always work in situations in which generics would, and definitely not in the same way.

What I find really fascinating is the staunch refusal to recognise that the success of NextStep and as such, the polish of the Mac OS operating system all come down to late binding allowing more freedom.  There are numerous projects that refuse to use =dyn Trait= out of principle, despite that simplifying their code substantially.  If your code is twice as long, half as readable, and compiles to the same assembly as if you used an opaque type or a generic, you are not allowed to talk about Rust.

* Conclusion

Rust is OOP.  It is in fact, OOP at its best so far.  It is no way comparable to OCaml (and definitely not StandardML), but it is comparable to C++ or SmallTalk, even though those languages still have certain advantages, nothing in tech is ever a direct upgrade.

* Footnotes
[fn:5]: Some are under the false impression that this implies that the state *cannot* be accessed outside that object.  This is completely untrue, because knowing the layout of the object allows one to read the end-point of a raw pointer, in languages other than Java.  And if you think that you will always only be interacting with Java from Java, you are sorely mistaken.

[fn:4]: Notice how none of the neat examples in OOP, come from actual life situations and almost always are reduced to contrived examples where a clear class hierarchy of the type "is a" can be established.  This is why OOP has fallen out of favour these days.

[fn:3]:  Outside the OOP world, in a procedural language like C, every field of every structure is always available.  So you can always do =thing.state= to read the state of an object.  In OOP, this is problematic, so in something like C++, you are encouraged to either delineate which translation units are allowed to access the state of an object and which aren't.  But in some cases, access can mean either read or write.  Instead of coming up with a permission system a-la Unix, we have instead invented a convention, wherein we restrict both read and write access, and when we need read access, we call =thing.get_state()=, or =thing.set_state(new_thing_state)= where the method =set_state= is responsible for ensuring that the object remains in a valid state[fn:2].  But here is the problem.  This led people to make "safe" assumptions about what the state can be.  So idiotic guidelines along the lines of "if it doesn't have to be publicly visible, make it private" were invented, without actually telling people that...  you know...  there aren't always resources to make the call =thing.set_state(new_thing_state)= to compile down to what the programmer actually wants.  This is a minor problem, compared to yet another guideline: "mark every member of every class that is private with a dumb prefix of your manager's choosing".  For example, if you happen to be working with Qt, your private variables are to be prefixed with =m_=, as if we can't already tell that you're a moron who refuses to use a machine that can properly differentiate private and public members in the editor window.


[fn:2]: A lot of the time, this logic cannot be delegated to anyone else, and because the typing system of C++ is stronger, but weak enough to be compatible with C, you cannot state that something is =unsigned int= and have that communicate to the programmer that they can't exactly set the value to a negative number.

[fn:1]: The reason is quite quaint.  Firstly, as can be seen with something like an =AtomicU64= or /e.g./ anything wrapped in a =Mutex=, not having a mutable reference isn't a guarantee of immutability, just that the mutation is properly synchronised.
